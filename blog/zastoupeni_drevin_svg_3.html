<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>Generujeme SVG z POSTGISu</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="generujeme-svg-z-postgisu">
<h1 class="title">Generujeme <cite>SVG</cite> z POSTGISu</h1>
<h2 class="subtitle" id="zastoupeni-drevin-po-orp-generalizace">Zastoupení dřevin po ORP - generalizace</h2>

<p>Generalizace je zvláštní disciplína, lhal bych, kdybych se prohlásil za znalého celé šíře této problematiky. Koneckonců vybočuje z mojí praxe dataře, protože se zabývá, v podstatě, vizuálnem, což je mimo ohnisko mých obvyklých zájmů. Cílem je při maximální možné redukci objemu dat zachovat maximum jejich obsahu. Zde narážíme na to, čemu se v ekologii říká <cite>trade off</cite>, čili, jste-li kachnou a váš zobák je placatý, bude obtížné s ním někoho, dejme tomu, uklovat, s nohami uzpůsobenými k plavání se bude špatně hrabat a tak dále. S daty je to podobné, mezi jejich objemem a jejich obsahem, je přímá úměra. V našem případě potřebujeme zachovat vzájemnou polohu jednotlivých polygonů a jejich vzájemnou polohu. Přesný průběh hranic nás netrápí, protože v měřítku, ve kterém pracujeme (celá republika) nejsou beztoho patrné. Taktéž drobné topologické <em>špinky</em> se ztratí, pokud jejich velikost nepřekročí půl kilometru.</p>
<div class="section" id="st-simplify">
<h1>ST_Simplify</h1>
<p>Generalizace obnáší množství různých úkonů. Vynechávání nevýznamných prvků, slučování, zjednodušování existujících prvků a tak dále. My se budeme zabývat zjednodušováním hranic existujících prvků. PostGIS nabízí funkce <a class="reference external" href="http://www.postgis.org/docs/ST_Simplify.html">ST_Simplify</a> a
<a class="reference external" href="http://www.postgis.org/docs/ST_SimplifyPreservrTopology.html">ST_SimplifyPreserveTopology</a>. Funkce pracuje s <a class="reference external" href="http://en.wikipedia.org/wiki/Ramer–Douglas–Peucker_algorithm">Douglas-Peckerovým algoritmem</a>. Výstup <a class="reference external" href="http://www.scielo.br/scielo.php?pid=S0104-65002004000100006&amp;script=sci_arttext">Douglas-Peckerova algorytmu</a> si můžeme představit asi jako kdybychom na linii navlékli ohebnou trubku a výsledkem byla její osa. Postupuje se tak, že se postupně přidávají body ohybu, přičemž se přidává vždy bod nejvzdálenější od aktuální osy, dokud nejsou všechny body v rouře. Poloměr roury (tolerance) je vstupním parametrem obou funkcí. Funkce jsou dvě z toho důvodu, že generalizací může dojít k porušení topologické validity prvku ST_SimplifyPreserveTopology toto ošetřuje, ST_Simplify vrací invalidní prvek.</p>
<p>Geometrii máme v tabulce orpecka od minula. Je v položce generalizovanehranice (originalnihranice je prázdná). Je to proto, že už jsme stáhli data, do nějaké míry generalizovaná. Nicméně generalizace není pro náš účel (respektive měřítko) dostačující. Při generalizaci vždy kopírujeme data do nového sloupce a to proto, že generalizace je nevrtaný proces a jednou ztracenou přesnost nelze zpětně obnovit.</p>
<pre class="literal-block">
SELECT
slhp_id_orp
, MULTI(ST_SimplifyPreserveTopology(generalizovanehranice, 1000))::geometry('MULTIPOLYGON', 5514) geom
INTO hratky_se_svg.generalizovany_orp
FROM hratky_se_svg.orpecka;
</pre>
<p>Všiměte si funkce <cite>MULTI</cite>, kterou jsem použil přes výsledek Simplify. Je to proto, že pracuji s vrstvou typu multipolygon, nicméně simplify v případě, že vrací jeden polygon, tak udělá z multipolygonu s jedním polygonem jednoduchý polygon. Použití této funkce zajistí, že všechny vracené prvky budou multipolygony.</p>
<p>Výsledkem si můžeme prohlédnout v QGISU.</p>
<img alt="obrazky/generalizace_bez_topologie.jpg" src="obrazky/generalizace_bez_topologie.jpg" />
<p>detaily</p>
<img alt="obrazky/generalizace_bez_topologie_2.jpg" src="obrazky/generalizace_bez_topologie_2.jpg" />
<p>Zobrazíme si, kde došlo k překryvům. Následjící dotaz můžete zkopírovat do SQL okna db manageru a výsledek dotazu přidat jako novou vrstvu.</p>
<pre class="literal-block">
SELECT
row_number() over(order by a.slhp_id_orp, b.slhp_id_orp) id
, MULTI(ST_AsText(ST_CollectionExtract(ST_Intersection(a.geom, b.geom), 3))) geom
FROM hratky_se_svg.generalizovany_orp a, hratky_se_svg.generalizovany_orp b
WHERE a.geom &amp;&amp; b.geom
AND ST_Relate (a.geom, b.geom, '2********')
AND a.slhp_id_orp != b.slhp_id_orp
</pre>
<p>Vidíme funkci <cite>MULTI</cite>, se kterou jsme se již seznámili, dále <cite>ST_CollectionExtract</cite>, kdy z GEOMETRYCOLLECTION, který může intersection také vracet vybereme jen a pouze polygony. To provedeme jen na překrývajících se polygonech, které nemají stejné id. Pro urychlení dotazu si pomůžeme předvýběrem pomocí operátoru <cite>&amp;&amp;</cite>.</p>
<img alt="obrazky/rozdily.png" src="obrazky/rozdily.png" />
<img alt="obrazky/rozdily_qgis.jpg" src="obrazky/rozdily_qgis.jpg" />
<p>Je vidět, že topologie dostala pořádně na frak. Je zjevné, že budeme muset pracovat s topologií, pokud chceme dostat spojitou vrstvu bez překryvů. Jedna z možností je generalizovat nikoliv polygony, ale jednotlivé hrany. Postup jsem našel na blogu věnovaném <a class="reference external" href="http://strk.keybit.net/blog/2012/04/13/simplifying-a-map-layer-using-postgis-topology/">topologické generalizaci</a>.</p>
<p>Postup zde prezentovaný pracuje nikoliv s polygony, nýbrž s hranami uloženými v topologickém schématu. Někdo ovšem může dojít ke kolizi dvou hran, například v případě různých konkávních útvarů, kdy jsou dvě hrany blízko sebe a vnější hrana s větším poloměrem je vyrovnána. To je zde řešeno tak, že v případě kolize je postupně u problematické hrany snižována tolerance, dokud hrany nepřestanou kolidovat. Ve výsledku to ovšem znamená, že ne všechny hrany jsou generalizované se stejnou tolerancí, což může na výsledku působit rušivě.</p>
<p>Já se nakonec rozhodl použít funkci ST_Simplify z rozšíření PostGISu <cite>topology</cite>, která se liší od ST_Simplify z PostGISu jako takového, protože pracuje s topogeometriemi místo geometriemi. Je to nová funkce a ještě není v dokumentaci.</p>
<p>Aby to bylo  možné provést, je třeba nainstalovat rozšíření PostgreSQL <cite>postgis_topology</cite>. Nejlépe pomocí <cite>CREATE EXTENSION</cite>.</p>
<pre class="literal-block">
CREATE EXTENSION postgis_topology;
</pre>
<p>Případně puštěním skriptu topology.sql z vaší složky s postgisem.</p>
<p>Nejdříve si vyrobíme schéma s topologií.</p>
<pre class="literal-block">
SELECT CreateTopology('orp_topo', 5514);
</pre>
<p>Parametry jsou název, SRID a volitelně tolerance.</p>
<p>K tabulce orpecka přidám topogeometrický sloupec topogeom.</p>
<pre class="literal-block">
SELECT AddTopoGeometryColumn('orp_topo', 'hratky_se_svg', 'orpecka', 'topogeom', 'MULTIPOLYGON');
</pre>
<p>Sloupec topogeom naplním daty.</p>
<pre class="literal-block">
SET SEARCH_PATH = hratky_se_svg, public, topology;

UPDATE orpecka
SET topogeom = toTopoGeom(generalizovanehranice, 'orp_topo', 1);
</pre>
<p>Teď si můžeme výsledek zgeneralizovat, vysypat do tabulky a prohlédnout v QGISu.</p>
<pre class="literal-block">
SELECT
slhp_id_orp, topology.ST_Simplify(topogeom, 500) geomsimp
INTO hratky_se_svg.generalizovany_polygony
FROM orpecka;
</pre>
<img alt="obrazky/topologicka_generalizace.jpg" src="obrazky/topologicka_generalizace.jpg" />
<img alt="obrazky/topologicka_generalizace_detaily.jpg" src="obrazky/topologicka_generalizace_detaily.jpg" />
<p>Výsledek vypadá na první i druhý pohled dokonale, přesto zkontrolujeme překryvy...</p>
<pre class="literal-block">
SELECT
row_number() over(order by a.slhp_id_orp, b.slhp_id_orp) id
, MULTI(ST_AsText(ST_CollectionExtract(ST_Intersection(a.geomsimp, b.geomsimp), 3))) geom
FROM hratky_se_svg.generalizovany_polygony a, hratky_se_svg.generalizovany_polygony b
WHERE a.geomsimp &amp;&amp; b.geomsimp
AND ST_Relate (a.geomsimp, b.geomsimp, '2********')
AND a.slhp_id_orp != b.slhp_id_orp
</pre>
<p>A zjistíme, že se nám zde, přeci jenom vyskytly nějaké <cite>fujtajblíky</cite>.</p>
<img alt="obrazky/chyba1.jpg" src="obrazky/chyba1.jpg" />
<p>a</p>
<img alt="obrazky/chyba2.jpg" src="obrazky/chyba2.jpg" />
<p>Modrá čára je původní hranice.</p>
<p>Problém není natolik závažný, abychom se jím museli zabývat. Nicméně stojí za zmínku, že problémem jsou podlouhlé, zahnuté útvary, se kterými se algorytmus obtížně vyrovnává. Pravděpodobně by bylo možné problém vyřešit nějak automaticky, nicméně nízká frekvence chyb a složitost problému ve výsledku vede k tomu, že podobná smítka je nejrychlejší opravit ručně.</p>
<p>Nyní můžeme zakomponovat výsledek do dotazu na generování svg.</p>
<pre class="literal-block">
SET SEARCH_PATH = hratky_se_svg, public;


\a \t \o orp_jasan_generalizovany.svg

SELECT
XMLELEMENT(NAME svg,
   XMLATTRIBUTES(
   600 AS height
   , 800 AS width
   , array_to_string(ARRAY[MIN(ST_XMIN(generalizovanehranice)) - 2500, -1 * (MAX(ST_YMAX(generalizovanehranice))) - 2500
      , (&#64;(MAX(ST_XMAX(generalizovanehranice)) - MIN(ST_XMIN(generalizovanehranice)))) + 5000
      , (&#64;(MAX(ST_YMAX(generalizovanehranice)) - MIN(ST_YMIN(generalizovanehranice)))) + 5000], ' ') AS &quot;viewBox&quot;
      , 'http://www.w3.org/2000/svg' AS xmlns, '1.1' AS version
   )
   , XMLAGG (
      XMLELEMENT(NAME path,
         XMLATTRIBUTES(
            ST_AsSVG(generalizovanehranice, 0, 0) AS d
            , 'black' AS stroke
            , 300 AS &quot;stroke-width&quot;
            , 'rgb('||(2.55*(100-(plocha_proc*4)))::int||',255,'||(2.55*(100-(plocha_proc * 4)))::int||')' AS fill
         )
      )
   )
)

FROM (SELECT topology.ST_Simplify(topogeom, 500) generalizovanehranice, plocha_proc
   FROM orpecka o, slhp s
   WHERE o.slhp_id_orp = s.id_orp
   AND drevina = 'jasan'
) g;

\o \a \t
</pre>
<object data="obrazky/orp_jasan_generalizovany.svg" type="image/svg+xml">
obrazky/orp_jasan_generalizovany.svg</object>
<p>Výsledek, jak patrno, nijak zvlášť vizuálně neutrpěl.</p>
<p>Velikost souboru můžeme ještě dále zredukovat jedním šikovným trikem. Křovákovo zobrazení pracuje, jak známo, s poněkud výstředními souřadnicemi.</p>
<p>Proto si křováka poupravíme a souřadnice zredukujeme o konstantu odpovídající maximální absolutní hodnotě x a y a také změníme jednotky z metrů na kilometry.</p>
<p>Nejdříve přidám nový souřadný systém. Příkaz je třeba uložit do samostatného souboru a spustit pomocí <cite>i</cite>, nebo z shellu pomocí <cite>psql -f</cite>.</p>
<pre class="literal-block">
COPY spatial_ref_sys FROM STDIN;
1    jelen   5514    \N      +proj=krovak +lat_0=49.5 +lon_0=24.83333333333333 +alpha=30.28813972222222 +k=0.9999 +x_0=905000 +y_0=1228000 +ellps=bessel +pm=greenwich +units=km +no_defs
\.
</pre>
<p>Původní definici křovákova zobrazení jsem upravil editací parametrů pro <cite>false easting a false northing</cite> tedy <cite>+x_0</cite> a <cite>+y_0</cite> zadáním hodnoty, která bude přičtena ke každé souřadnici a dále změnil <cite>+units</cite> z metrů na kilometry.</p>
<pre class="literal-block">
SET SEARCH_PATH = hratky_se_svg, public;


\a \t \o orp_jasan_generalizovany_srid_1.svg

SELECT
XMLELEMENT(NAME svg,
   XMLATTRIBUTES(
   600 AS height
   , 800 AS width
   , array_to_string(ARRAY[MIN(ST_XMIN(generalizovanehranice)) - 2.5, -1 * (MAX(ST_YMAX(generalizovanehranice))) - 2.5
      , (&#64;(MAX(ST_XMAX(generalizovanehranice)) - MIN(ST_XMIN(generalizovanehranice)))) + 5
      , (&#64;(MAX(ST_YMAX(generalizovanehranice)) - MIN(ST_YMIN(generalizovanehranice)))) + 5], ' ') AS &quot;viewBox&quot;
      , 'http://www.w3.org/2000/svg' AS xmlns, '1.1' AS version
   )
   , XMLAGG (
      XMLELEMENT(NAME path,
         XMLATTRIBUTES(
            ST_AsSVG(generalizovanehranice, 0, 0) AS d
            , 'black' AS stroke
            , 0.3 AS &quot;stroke-width&quot;
            , 'rgb('||(2.55*(100-(plocha_proc*4)))::int||',255,'||(2.55*(100-(plocha_proc * 4)))::int||')' AS fill
         )
      )
   )
)

FROM (SELECT ST_Transform(topology.ST_Simplify(topogeom, 500) ,1) generalizovanehranice, plocha_proc
   FROM orpecka o, slhp s
   WHERE o.slhp_id_orp = s.id_orp
   AND drevina = 'jasan'
) g;

\o \a \t
</pre>
<p>Musel jsem ještě změnit hodnoty odečítané pro <cite>viewBox</cite> vydělením tisícem a to samé pro <cite>stroke-width</cite>.</p>
<object data="obrazky/orp_jasan_generalizovany_srid1.svg" type="image/svg+xml">
obrazky/orp_jasan_generalizovany_srid1.svg</object>
<p>Příště se podíváme, jak obarvit svg pomocí kaskádového stylu a jak šikovně použít javascript k přepínání mezi barvami pro jednotlivé dřeviny.</p>
</div>
</div>
</body>
</html>
